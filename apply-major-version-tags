#!/usr/bin/env ruby

require_relative "./lib/error_mixin"
require_relative "./lib/plugin"
require_relative "./lib/plugin_collection"
require_relative "./lib/plugin_library_updater"

require "bundler/setup"
require "dotenv"
require "English"
require "json"
require "rubygems"
require "time"
require "zip"

Dotenv.load

# A Plugin is a representation of a GitHub repository that mirrors a
# plugin from wordpress.org. Plugins are responsible for updating
# their related repositories.
class Plugin < AbstractPlugin
  attr_reader :latest_major_version

  def populate_version_information
    @latest_plugin_version_on_github = fetch_latest_plugin_version_on_github
    raise MissingVersionError, "No version tags found for #{slug}" if @latest_plugin_version_on_github == ""
    split_tag = @latest_plugin_version_on_github.split(".")
    major_tag = split_tag[0]
    major_tag.prepend("v") unless major_tag.start_with?("v")
    @latest_major_version = major_tag
  end

  def update_major_version_tag
    puts "==> Cloning the #{@slug} GitHub repo..."
    `git clone #{construct_github_https_url} #{@full_path_to_clone}`
    raise GitError, "Could not clone #{@github_url}" unless $CHILD_STATUS.success?

    puts "==> Tagging the repo with the latest major version tag..."
    tag
    `git -C #{@full_path_to_clone} status`
    puts "==> Updating the GitHub repo..."
    if dry_run?
      puts "... -- Dry run mode, no repo pushing taking place --"
    else
      `git -C #{@full_path_to_clone} push --tags --force`
      raise GitError, "Could not push to #{@github_url}" unless $CHILD_STATUS.success?
    end
    cleanup
  end

  private

  def tag
    `git -C #{@full_path_to_clone} tag -f #{@latest_major_version} #{@latest_plugin_version_on_github}`
  end
end

# Get information about organisation plugins from GitHub and transform into an
# array of Plugin objects.
class PluginCollection < AbstractPluginCollection
  @@last_updated_range = 43_200 # 12 hours in seconds - we're going to run this more frequently than the actual mirroring, so this should be plenty

  def build
    projects = JSON.parse(plugin_library_repos)
    puts "==> Found #{projects.size} plugins in the library"
    projects.each do |project|
      unless force_update?
        updated_date_time = Time.parse(project["updatedAt"])
        next project if (Time.now - updated_date_time) > @@last_updated_range
      end
      plugin = Plugin.new(project["name"], project["url"])
      next project if plugin.nil?
      @plugins.push(plugin)
    end
    @plugins
  end
end

# Update all repositories in a GitHub organisation, assuming each one has been
# mirrored from wordpress.org. Optionally print a summary of the updates
# that have been performed or have errored.
class PluginLibraryTagger < AbstractPluginLibraryUpdater
  def initialize
    @start_time = nil
    @end_time = nil
    super
  end

  def update
    @start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    plugins = PluginCollection.new.build
    plugins.each do |plugin|
      hrule
      puts "==> Checking status of #{plugin.slug}..."
      begin
        plugin.populate_version_information
      rescue MissingVersionError => e
        @failed_updates[plugin.slug] =
          e.message.empty? ? "error retrieving version tags for #{plugin.slug}" : e.message.to_s
        next plugin
      end
      puts "...applying major tag to it now"
      begin
        plugin.update_major_version_tag
        @updated_plugins[plugin.slug] = {
          major_tag: plugin.latest_major_version,
          corresponding_version: plugin.latest_plugin_version_on_github
        }
      rescue PluginUpdateError => e
        @failed_updates[plugin.slug] = e.message
        plugin.cleanup
      end
    end
    @end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    elapsed_time = @end_time - @start_time
    puts "==> Applying major version takes took: #{(elapsed_time / 60).round}m#{(elapsed_time % 60).round}s."
  end

  private

  def print_updated_plugin_summary
    return if @updated_plugins.empty?
    hrule
    puts "==> Updated the following #{@updated_plugins.size} plugin(s):"
    @updated_plugins.each do |name, version_hash|
      puts "#{name} #{version_hash[:corresponding_version]} tagged as #{version_hash[:major_tag]}"
    end
  end
end

def dry_run?
  ENV["DRY_RUN_TAGGER"] == "true"
end

def force_update?
  ENV["FORCE_UPDATE_TAGGER"] == "true"
end

puts "==> -- Dry run mode --" if dry_run?

puts "==> -- Force update mode --" if force_update?

tagger = PluginLibraryTagger.new
tagger.update
tagger.print_summary
